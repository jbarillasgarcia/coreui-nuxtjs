'use strict';

exports.__esModule = true;

var _each = require('lodash/each');

var _each2 = _interopRequireDefault(_each);

var _forOwn = require('lodash/forOwn');

var _forOwn2 = _interopRequireDefault(_forOwn);

var _Sandbox = require('../Sandbox');

var _Sandbox2 = _interopRequireDefault(_Sandbox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var sandbox = function sandbox() {
  for (var _len = arguments.length, sandboxArgs = Array(_len), _key = 0; _key < _len; _key++) {
    sandboxArgs[_key] = arguments[_key];
  }

  return function (Target) {
    var sandboxInstance = new (Function.prototype.bind.apply(_Sandbox2.default, [null].concat(sandboxArgs)))();

    var addMethod = function addMethod(obj, key, value) {
      if (obj[key]) {
        throw new Error('Cannot apply sandbox decorator ' + key + ' property is already defined.');
      }
      obj[key] = value;
    };

    return function (_Target) {
      _inherits(_class, _Target);

      function _class() {
        var _ref;

        _classCallCheck(this, _class);

        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        var _this = _possibleConstructorReturn(this, (_ref = _class.__proto__ || Object.getPrototypeOf(_class)).call.apply(_ref, [this].concat(args)));

        (0, _each2.default)(['loadPerimeter', 'loadModule', 'guard', 'isAllowed', 'isNotAllowed', 'hasPerimeter', 'getPerimeter', 'getPerimeters', 'governess'], function (key) {
          addMethod(_this, key, sandboxInstance[key]);
        });

        (0, _forOwn2.default)(sandboxInstance, function (val, key) {
          addMethod(_this, key, val);
        });
        return _this;
      }

      return _class;
    }(Target);
  };
};

exports.default = sandbox;