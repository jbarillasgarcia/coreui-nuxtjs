'use strict';

exports.__esModule = true;
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extend = require('lodash/extend');

var _extend2 = _interopRequireDefault(_extend);

var _isObject = require('lodash/isObject');

var _isObject2 = _interopRequireDefault(_isObject);

var _isString = require('lodash/isString');

var _isString2 = _interopRequireDefault(_isString);

var _omit = require('lodash/omit');

var _omit2 = _interopRequireDefault(_omit);

var _keys = require('lodash/keys');

var _keys2 = _interopRequireDefault(_keys);

var _each = require('lodash/each');

var _each2 = _interopRequireDefault(_each);

var _AllowedMethodsService = require('./utils/AllowedMethodsService');

var _AllowedMethodsService2 = _interopRequireDefault(_AllowedMethodsService);

var _HeadGoverness = require('./governesses/HeadGoverness');

var _HeadGoverness2 = _interopRequireDefault(_HeadGoverness);

var _utils = require('./utils');

var _errors = require('./errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var allowedMethodsService = new _AllowedMethodsService2.default({});

/**
 * A Perimeter is used to define the places where child can play.
 */

var Perimeter = function () {
  /**
   * Create new perimeter
   */
  function Perimeter(purpose) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Perimeter);

    if ((0, _isObject2.default)(purpose) && (0, _isString2.default)(purpose.purpose)) {
      opts = purpose;
      this.purpose = purpose.purpose;
    }

    this.purpose = this.purpose || purpose;
    this.govern = this.extractGovern(opts);
    this.expose = opts.expose || [];

    if (!(0, _utils.isGoverness)(opts.governess)) {
      try {
        var Governess = opts.governess;
        this.governess = new Governess();
      } catch (ignore) {
        // ignore...
      }
    }

    this.governess = this.governess || opts.governess;

    // Perimeter doesn't require governess
    if ((0, _utils.isGoverness)(this.governess)) {
      this.governess.learnRules(this);
    }

    (0, _extend2.default)(this, (0, _omit2.default)(opts, ['purpose', 'govern', 'expose', 'governess']));
  }

  /**
   * The getter of the purpose.
   */


  _createClass(Perimeter, [{
    key: 'getPurpose',


    /**
     * Returns purpose of the perimeter.
     */
    value: function getPurpose() {
      return this.purpose;
    }

    /**
     * The getter of the sandbox.
     */

  }, {
    key: 'getSandbox',


    /**
     * Returns sandbox of the perimeter
     */
    value: function getSandbox() {
      return this.sandbox;
    }

    /**
     * The getter of the governess.
     */

  }, {
    key: 'getGoverness',


    /**
     * Return the governess of the perimeter or the governess of it's sandbox
     */
    value: function getGoverness() {
      return this.governess;
    }

    /**
     * Return true if perimeter has it's own governess.
     */

  }, {
    key: 'hasOwnGoverness',
    value: function hasOwnGoverness() {
      return (0, _utils.isGoverness)(this._governess);
    }

    /**
     * Forward guard call to governess.
     */

  }, {
    key: 'guard',
    value: function guard() {
      var _governess$guard;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return (_governess$guard = this.governess.guard).call.apply(_governess$guard, [this.governess].concat(args));
    }

    /**
     * Forward governed call to governess.
     */

  }, {
    key: 'governed',
    value: function governed() {
      var _governess$governed;

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return (_governess$governed = this.governess.governed).call.apply(_governess$governed, [this.governess].concat(args));
    }

    /**
     * Forward isAllowed call to governess.
     */

  }, {
    key: 'isAllowed',
    value: function isAllowed() {
      var _governess$isAllowed;

      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return (_governess$isAllowed = this.governess.isAllowed).call.apply(_governess$isAllowed, [this.governess].concat(args));
    }

    /**
     * Forward isNotAllowed call to governess.
     */

  }, {
    key: 'isNotAllowed',
    value: function isNotAllowed() {
      var _governess$isNotAllow;

      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return (_governess$isNotAllow = this.governess.isNotAllowed).call.apply(_governess$isNotAllow, [this.governess].concat(args));
    }
  }, {
    key: 'extractGovern',
    value: function extractGovern(_ref) {
      var govern = _ref.govern,
          can = _ref.can,
          cannot = _ref.cannot;

      govern = govern || {};

      (0, _each2.default)((0, _keys2.default)(can || {}), function (key) {
        govern['can ' + key] = can[key];
      });

      (0, _each2.default)((0, _keys2.default)(cannot || {}), function (key) {
        govern['cannot ' + key] = cannot[key];
      });

      return govern;
    }
  }, {
    key: 'purpose',
    get: function get() {
      return this._purpose;
    }

    /**
     * The setter of the purpose. Make sure that name of the purpose is not
     * restricted.
     */
    ,
    set: function set(value) {
      if (!(0, _isString2.default)(value) || allowedMethodsService.isRestricted(value)) {
        throw new _errors.NoPurposeError();
      }

      this._purpose = value;

      return value;
    }
  }, {
    key: 'sandbox',
    get: function get() {
      return this._sandbox;
    }

    /**
     * The setter of the sandbox.
     * Make sure that given sandbox is an instance of Sandbox class.
     */
    ,
    set: function set(value) {
      if (!(0, _utils.isSandbox)(value)) {
        throw new _errors.NoSandboxError();
      }

      this._sandbox = value;
      this.child = value.child;

      return value;
    }
  }, {
    key: 'governess',
    get: function get() {
      var _this = this;

      return this.hasOwnGoverness() ? this._governess : function () {
        return (0, _utils.isSandbox)(_this.sandbox) ? _this.sandbox.governess : null;
      }();
    }

    /**
     * The setter of the governess.
     */
    ,
    set: function set(value) {
      var _this2 = this;

      // if governess is null perimeter will use the governess of it's sandbox
      this._governess = (0, _utils.isGoverness)(value) ? value : function () {
        return (0, _utils.isSandbox)(_this2.sandbox) ? _this2.sandbox.governess : null;
      }();

      // Make sure governess know all the rules
      if ((0, _isObject2.default)(this._governess) && this._governess instanceof _HeadGoverness2.default) {
        this._governess.learnRules(this);
      }

      return value;
    }
  }]);

  return Perimeter;
}();

exports.default = Perimeter;