'use strict';

exports.__esModule = true;
exports.default = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _find = require('lodash/find');

var _find2 = _interopRequireDefault(_find);

var _isArray = require('lodash/isArray');

var _isArray2 = _interopRequireDefault(_isArray);

var _isEmpty = require('lodash/isEmpty');

var _isEmpty2 = _interopRequireDefault(_isEmpty);

var _isFunction = require('lodash/isFunction');

var _isFunction2 = _interopRequireDefault(_isFunction);

var _isRegExp = require('lodash/isRegExp');

var _isRegExp2 = _interopRequireDefault(_isRegExp);

var _memoize = require('lodash/memoize');

var _memoize2 = _interopRequireDefault(_memoize);

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Definition = function () {
  function Definition(rule, def) {
    _classCallCheck(this, Definition);

    this.TYPES = [[
    // The name of the definition type
    'items',
    // Condition that has to be met for raw value
    function (ruleDef) {
      return (0, _isArray2.default)(ruleDef) && !(0, _isEmpty2.default)(ruleDef);
    }, false // is not strict
    ], [
    // The name of the definition type
    'regex',
    // Condition that has to be met for raw value
    function (ruleDef) {
      return (0, _isRegExp2.default)(ruleDef);
    }, true // is strict
    ], [
    // The name of the definition type
    'customMethod',
    // Condition that has to be met for raw value
    function (ruleDef) {
      return (0, _isFunction2.default)(ruleDef);
    }, true // is strict
    ]];

    this.rule = rule;

    this.raw = def;

    this._resolve();
  }

  _createClass(Definition, [{
    key: 'isStrict',
    value: function isStrict() {
      return !this.rule.type.isPositive() || this._isStrict(this.type);
    }
  }, {
    key: '_resolve',
    value: function _resolve() {
      var _this = this;

      var definitionObj = (0, _find2.default)(this.TYPES, function (type) {
        var condition = type[1];

        return condition(_this.raw);
      }) || null;

      if (!(0, _isArray2.default)(definitionObj)) {
        throw new _errors.WrongRuleDefinition('Cannot create a new rule "' + this.rule.type.type + '". Wrong rule definition.');
      }

      if ((0, _isFunction2.default)(this.raw) && this.raw.ruleContext) {
        this.ruleContext = this.raw.ruleContext;
      }

      // set the type of the rule definition (items/customMethod/regex/...)

      var _definitionObj = _slicedToArray(definitionObj, 1);

      this.type = _definitionObj[0];


      this[this.type] = this.raw;
    }
  }]);

  return Definition;
}();

exports.default = Definition;


Definition.prototype._isStrict = (0, _memoize2.default)(function (type) {
  return ((0, _find2.default)(this.TYPES, function (t) {
    return type === t[0];
  }) || [])[2] || false;
});